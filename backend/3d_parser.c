#include "3d_parser.h"

/**
 * @brief Загружает трехмерную модель из файла в память.
 *
 * Эта функция считывает трехмерную модель из файла, указанного в параметре
 * filename. Она устанавливает числовую локаль на "C" для обеспечения
 * однородного форматирования десятичной точки, открывает файл для чтения и
 * поочередно разбирает строки файла для извлечения вершин и граней модели.
 * Разобранные данные сохраняются в предоставленной структуре Model.
 *
 * @param filename Имя файла, из которого следует считать данные модели.
 * @param model Указатель на указатель Model, куда будут сохранены загруженные
 * данные модели.
 * @return Целое число, указывающее на результат операции.
 *         Возвращает OK в случае успешного выполнения или ERROR, если произошла
 * ошибка (например, файл не найден).
 */
int _get_model(const char *filename, Model **model) {
  // Установка числовой локали на "C" для обеспечения однородного форматирования
  // десятичной точки
  setlocale(LC_NUMERIC, "C");

  // Попытка открыть указанный файл для чтения
  FILE *file = fopen(filename, "r");
  if (file == NULL) {
    return ERROR;  // Возврат кода ошибки, если файл не может быть открыт
  }

  // Инициализация переменных
  int status = OK;  // Статус операции
  (*model) = malloc(sizeof(Model));  // Выделение памяти для структуры Model
  (*model)->faces = malloc(sizeof(Face));  // Выделение памяти для массива Face
  (*model)->vertexes =
      malloc(sizeof(Vertex));  // Выделение памяти для массива Vertex
  (*model)->num_of_faces = 0;  // Инициализация количества граней нулем
  (*model)->total_vertexes = 0;  // Инициализация общего числа вершин нулем
  char buffer[BUFFER_SIZE];  // Временный буфер для чтения строк из файла

  // Считывание и обработка каждой строки из файла
  while (fgets(buffer, BUFFER_SIZE, file) != NULL) {
    if (_starts_with("v ", buffer)) {
      status = _parse_vertexes(model, buffer);  // Разбор данных вершин
    } else if (_starts_with("f ", buffer)) {
      status = _parse_faces(model, buffer);  // Разбор данных граней
    }
  }

  // Закрытие файла после обработки
  fclose(file);

  return status;  // Возврат окончательного статуса операции
}

/**
 * @brief Разбирает строку, содержащую данные вершины, и добавляет вершину в
 * модель.
 *
 * Эта функция разбирает строку buffer, содержащую данные вершины, и добавляет
 * извлеченную вершину в предоставленную структуру Model. Данные вершины (x, y,
 * z) извлекаются с помощью функции sscanf, а затем добавляются в массив вершин
 * модели.
 *
 * @param model Указатель на указатель Model, куда будет добавлена вершина.
 * @param buffer Строка, содержащая данные вершины в формате "v x y z".
 * @return Целое число, указывающее на результат операции.
 *         Возвращает OK в случае успешного разбора и добавления вершины, или
 * ERROR, если произошла ошибка.
 */
int _parse_vertexes(Model **model, char *buffer) {
  int status = OK;  // Статус операции
  float x, y, z;    // Координаты вершины

  // Извлечение координат вершины из строки
  if (sscanf(buffer, "v %f %f %f", &x, &y, &z) != 3) {
    status = ERROR;  // Ошибка, если извлечение не удалось
  } else {
    // Увеличение общего числа вершин и перераспределение памяти для массива
    // вершин
    (*model)->total_vertexes += 1;
    (*model)->vertexes =
        realloc((*model)->vertexes, (*model)->total_vertexes * sizeof(Vertex));

    // Добавление вершины в массив вершин модели
    (*model)->vertexes[(*model)->total_vertexes - 1].x = x;
    (*model)->vertexes[(*model)->total_vertexes - 1].y = y;
    (*model)->vertexes[(*model)->total_vertexes - 1].z = z;
  }

  return status;  // Возврат статуса операции
}

/**
 * @brief Разбирает строку, содержащую данные грани, и добавляет грань в модель.
 *
 * Эта функция разбирает строку buffer, содержащую данные грани, и добавляет
 * извлеченную грань в предоставленную структуру Model. Данные грани (индексы
 * вершин) извлекаются с помощью функции sscanf, а затем добавляются в массив
 * граней модели.
 *
 * @param model Указатель на указатель Model, куда будет добавлена грань.
 * @param buffer Строка, содержащая данные грани в формате "f v1/vt1/vn1
 * v2/vt2/vn2 v3/vt3/vn3 ...".
 * @return Целое число, указывающее на результат операции.
 *         Возвращает OK в случае успешного разбора и добавления грани, или
 * ERROR, если произошла ошибка.
 */
int _parse_faces(Model **model, char *buffer) {
  int status = OK;  // Статус операции

  buffer++;  // Пропуск первого символа ('f')

  int index;
  int v = 0;  // Количество вершин в грани
  int f = (*model)->num_of_faces;  // Индекс текущей грани

  (*model)->num_of_faces += 1;  // Увеличение количества граней
  (*model)->faces =
      realloc((*model)->faces,
              (*model)->num_of_faces *
                  sizeof(Face));  // Перераспределение памяти для массива граней
  (*model)->faces[f].vertexes =
      malloc(sizeof(int));  // Выделение памяти для массива индексов вершин

  // Цикл разбора индексов вершин грани
  while (buffer[0] != '\0' && status == OK) {
    if (sscanf(buffer, " %d/", &index) == 1) {
      (*model)->faces[f].vertexes =
          realloc((*model)->faces[f].vertexes, (v + 1) * sizeof(int));
      (*model)->faces[f].vertexes[v] = index;
      v++;

      // Пропуск символов до следующего индекса вершины
      do {
        buffer++;
      } while (buffer[0] != ' ' && buffer[0] != '\0');
    } else {
      status = ERROR;  // Ошибка, если извлечение индекса не удалось
    }
  }

  (*model)->faces[f].num_of_vertexes =
      v;  // Установка количества вершин в текущей грани
  return status;  // Возврат статуса операции
}

/**
 * @brief Проверяет, начинается ли строка с заданного префикса.
 *
 * Эта функция сравнивает строку `str` с заданным префиксом `pre`, чтобы
 * определить, начинается ли `str` с символов, указанных в `pre`. Если `str`
 * начинается с `pre`, функция возвращает `true`, в противном случае - `false`.
 *
 * @param pre Указатель на C-строку с префиксом, который мы хотим проверить.
 * @param str Указатель на C-строку, которую мы хотим проверить на наличие
 * префикса.
 * @return true, если `str` начинается с `pre`, иначе false.
 */
bool _starts_with(const char *pre, const char *str) {
  // Используем функцию strncmp для сравнения первых strlen(pre) символов строк
  // pre и str. Если результат равен 0, значит, префикс совпадает.
  return strncmp(pre, str, strlen(pre)) == 0;
}

/**
 * @brief Вращает вершину вокруг оси X на заданный угол.
 *
 * Эта функция вращает заданную вершину вокруг оси X на заданный угол.
 *
 * @param point Вершина, которую необходимо вращать.
 * @param angle Угол в радианах, на который следует повернуть вершину.
 * @return Новая вершина после вращения.
 */
Vertex rotateX(Vertex point, double angle) {
  Vertex result;  // Результирующая вершина после вращения

  // Вычисление координат новой вершины после вращения
  result.x = point.x;
  result.y = point.y * cos(angle) - point.z * sin(angle);
  result.z = point.y * sin(angle) + point.z * cos(angle);

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Вращает вершину вокруг оси Y на заданный угол.
 *
 * Эта функция вращает заданную вершину вокруг оси Y на заданный угол.
 *
 * @param point Вершина, которую необходимо вращать.
 * @param angle Угол в радианах, на который следует повернуть вершину.
 * @return Новая вершина после вращения.
 */
Vertex rotateY(Vertex point, double angle) {
  Vertex result;  // Результирующая вершина после вращения

  // Вычисление координат новой вершины после вращения
  result.x = point.x * cos(angle) + point.z * sin(angle);
  result.y = point.y;
  result.z = -point.x * sin(angle) + point.z * cos(angle);

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Вращает вершину вокруг оси Z на заданный угол.
 *
 * Эта функция вращает заданную вершину вокруг оси Z на заданный угол.
 *
 * @param point Вершина, которую необходимо вращать.
 * @param angle Угол в радианах, на который следует повернуть вершину.
 * @return Новая вершина после вращения.
 */
Vertex rotateZ(Vertex point, double angle) {
  Vertex result;  // Результирующая вершина после вращения

  // Вычисление координат новой вершины после вращения
  result.x = point.x * cos(angle) - point.y * sin(angle);
  result.y = point.x * sin(angle) + point.y * cos(angle);
  result.z = point.z;

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Перемещает вершину вдоль оси X на заданное расстояние.
 *
 * Эта функция перемещает заданную вершину вдоль оси X на заданное расстояние.
 *
 * @param point Вершина, которую необходимо переместить.
 * @param translate Расстояние для перемещения по оси X.
 * @return Новая вершина после перемещения.
 */
Vertex translateX(Vertex point, double translate) {
  Vertex result;  // Результирующая вершина после перемещения

  // Вычисление новых координат вершины после перемещения
  result.x = point.x + translate;
  result.y = point.y;
  result.z = point.z;

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Перемещает вершину вдоль оси Y на заданное расстояние.
 *
 * Эта функция перемещает заданную вершину вдоль оси Y на заданное расстояние.
 *
 * @param point Вершина, которую необходимо переместить.
 * @param translate Расстояние для перемещения по оси Y.
 * @return Новая вершина после перемещения.
 */
Vertex translateY(Vertex point, double translate) {
  Vertex result;  // Результирующая вершина после перемещения

  // Вычисление новых координат вершины после перемещения
  result.x = point.x;
  result.y = point.y + translate;
  result.z = point.z;

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Перемещает вершину вдоль оси Z на заданное расстояние.
 *
 * Эта функция перемещает заданную вершину вдоль оси Z на заданное расстояние.
 *
 * @param point Вершина, которую необходимо переместить.
 * @param translate Расстояние для перемещения по оси Z.
 * @return Новая вершина после перемещения.
 */
Vertex translateZ(Vertex point, double translate) {
  Vertex result;  // Результирующая вершина после перемещения

  // Вычисление новых координат вершины после перемещения
  result.x = point.x;
  result.y = point.y;
  result.z = point.z + translate;

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Масштабирует вершину на заданный коэффициент.
 *
 * Эта функция масштабирует заданную вершину на заданный коэффициент.
 *
 * @param point Вершина, которую необходимо масштабировать.
 * @param scale Коэффициент масштабирования.
 * @return Новая вершина после масштабирования.
 */
Vertex scale_vertex(Vertex point, double scale) {
  Vertex result;  // Результирующая вершина после масштабирования

  // Вычисление новых координат вершины после масштабирования
  result.x = point.x * scale;
  result.y = point.y * scale;
  result.z = point.z * scale;

  return result;  // Возврат результирующей вершины
}

/**
 * @brief Очищает память, занимаемую моделью.
 *
 * Эта функция освобождает память, занимаемую структурами данных модели.
 * Все массивы вершин и граней освобождаются, а указатель на модель
 * устанавливается в NULL.
 *
 * @param model Указатель на указатель Model, который будет освобожден.
 */
void _reset_model(Model **model) {
  if (model == NULL || *model == NULL) {
    return;  // Пропуск, если указатель на модель недействителен
  }

  // Освобождение памяти для каждой грани в модели
  for (int i = 0; i < (*model)->num_of_faces; i++) {
    free((*model)->faces[i].vertexes);
  }

  // Освобождение памяти для массива граней и вершин
  free((*model)->faces);
  free((*model)->vertexes);

  // Освобождение памяти для структуры Model и установка указателя в NULL
  free(*model);
  (*model) = NULL;
}

// int main(){
//     Model* model;
//   int status = _get_model("../Model/Lola Bunny.obj", &model);
//   printf("%d\n", status);
//   printf("%d\n", model->total_vertexes);
//   printf("%f\n", model->vertexes[0].x);
//   return 0;
// }